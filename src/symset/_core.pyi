from collections.abc import Iterable, Set as AbstractSet
from typing import Final, Literal, NoReturn, Self, final

@final
class EmptySetType:
    def __new__(cls, /) -> NoReturn: ...  # raises TypeError
    def __init__(self, /) -> NoReturn: ...  # raises TypeError
    def __bool__(self, /) -> Literal[False]: ...
    def __len__(self, /) -> Literal[0]: ...
    def __contains__(self, x: object) -> Literal[False]: ...
    def __lt__(self, /, other: AbstractSet[object]) -> bool: ...
    def __le__(self, /, other: AbstractSet[object]) -> bool: ...
    def __ge__(self, /, other: AbstractSet[object]) -> bool: ...
    def __gt__(self, /, other: AbstractSet[object]) -> bool: ...
    def __and__(self, /, other: AbstractSet[object]) -> Self: ...
    def __rand__(self, /, other: AbstractSet[object]) -> Self: ...
    def __or__[ST: AbstractSet[object]](self, /, other: ST) -> ST: ...
    def __ror__[ST: AbstractSet[object]](self, /, other: ST) -> ST: ...
    def __xor__[ST: AbstractSet[object]](self, /, other: ST) -> ST: ...
    def __rxor__[ST: AbstractSet[object]](self, /, other: ST) -> ST: ...
    def __sub__(self, /, other: AbstractSet[object]) -> Self: ...
    def __rsub__(self, /, other: AbstractSet[object]) -> Self: ...
    def isdisjoint(self, /, other: Iterable[object]) -> bool: ...

EMPTY_SET: Final[EmptySetType] = ...
