# pyright: reportIncompatibleMethodOverride=false

from collections.abc import Iterable, Iterator, Set as AbstractSet
from typing import Any, Final, Literal, Never, NoReturn, Self, final, override

@final
class EmptyType(AbstractSet[Never]):
    def __new__(cls, /) -> NoReturn: ...  # raises TypeError
    def __init__(self, /) -> NoReturn: ...  # raises TypeError
    def __bool__(self, /) -> Literal[False]: ...
    @override
    def __len__(self, /) -> Literal[0]: ...
    @override
    def __contains__(self, x: object, /) -> Literal[False]: ...
    @override
    def __iter__(self, /) -> Iterator[Never]: ...
    @override
    def __hash__(self, /) -> int: ...
    @override
    def __eq__(self, other: object, /) -> bool: ...
    @override
    def __ne__(self, other: object, /) -> bool: ...
    @override
    def __lt__(self, other: AbstractSet[Any], /) -> bool: ...
    @override
    def __le__(self, other: AbstractSet[Any], /) -> bool: ...
    @override
    def __ge__(self, other: AbstractSet[Any], /) -> bool: ...
    @override
    def __gt__(self, other: AbstractSet[Any], /) -> bool: ...
    @override
    def __and__(self, other: AbstractSet[Any], /) -> Self: ...
    @override
    def __or__[ST: AbstractSet[Any]](self, other: ST, /) -> ST: ...
    @override
    def __xor__[ST: AbstractSet[Any]](self, other: ST, /) -> ST: ...
    @override
    def __sub__(self, other: AbstractSet[Any], /) -> Self: ...
    @override
    def isdisjoint(self, other: Iterable[Any], /) -> bool: ...  # TODO: impl

Empty: Final[EmptyType] = ...
