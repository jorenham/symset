# pyright: reportImplicitOverride=false

from collections.abc import Iterable, Iterator, Set as AbstractSet
from typing import Any, Final, Literal, Never, NoReturn, Self, final

@final
class EmptySetType(AbstractSet[Never]):
    def __new__(cls, /) -> NoReturn: ...  # raises TypeError
    def __init__(self, /) -> NoReturn: ...  # raises TypeError
    def __bool__(self, /) -> Literal[False]: ...
    def __len__(self, /) -> Literal[0]: ...
    def __contains__(self, /, x: object) -> Literal[False]: ...
    def __iter__(self, /) -> Iterator[Never]: ...
    def __hash__(self, /) -> int: ...
    def __eq__(self, /, other: object) -> bool: ...
    def __ne__(self, /, other: object) -> bool: ...
    def __lt__(self, /, other: AbstractSet[Any]) -> bool: ...
    def __le__(self, /, other: AbstractSet[Any]) -> bool: ...
    def __ge__(self, /, other: AbstractSet[Any]) -> bool: ...
    def __gt__(self, /, other: AbstractSet[Any]) -> bool: ...
    def __and__(self, /, other: AbstractSet[Any]) -> Self: ...  # TODO: impl
    def __rand__(self, /, other: AbstractSet[Any]) -> Self: ...  # TODO: impl
    def __or__[ST: AbstractSet[Any]](self, /, other: ST) -> ST: ...  # TODO: impl
    def __ror__[ST: AbstractSet[Any]](self, /, other: ST) -> ST: ...  # TODO: impl
    def __xor__[ST: AbstractSet[Any]](self, /, other: ST) -> ST: ...  # TODO: impl
    def __rxor__[ST: AbstractSet[Any]](self, /, other: ST) -> ST: ...  # TODO: impl
    def __sub__(self, /, other: AbstractSet[Any]) -> Self: ...  # TODO: impl
    def __rsub__[ST: AbstractSet[Any]](self, /, other: ST) -> ST: ...  # TODO: impl
    def isdisjoint(self, /, other: Iterable[Any]) -> bool: ...  # TODO: impl

EMPTY_SET: Final[EmptySetType] = ...
